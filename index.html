<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Polyrhythm Player</title>
  <script src="https://cdn.jsdelivr.net/npm/tone@latest/build/Tone.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/tonal/browser/tonal.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #1a1a2e;
      color: #e0e0e0;
      font-family: 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
      display: flex;
      justify-content: center;
      padding: 20px;
    }

    .container {
      width: 100%;
      max-width: 600px;
    }

    h1 {
      text-align: center;
      margin-bottom: 16px;
      font-size: 1.5rem;
      color: #8be9fd;
      letter-spacing: 0.05em;
    }

    #visualizer {
      width: 100%;
      height: 300px;
      background: #0f0f23;
      border: 1px solid #333;
      border-radius: 8px;
      margin-bottom: 20px;
      display: block;
    }

    label {
      display: block;
      margin-bottom: 6px;
      font-size: 1.3rem;
      color: #aaa;
    }

    textarea {
      width: 100%;
      height: 300px;
      background: #16213e;
      color: #f8f8f2;
      border: 1px solid #333;
      border-radius: 6px;
      padding: 12px;
      font-family: 'Consolas', 'Courier New', monospace;
      font-size: 1.4rem;
      resize: vertical;
      margin-bottom: 20px;
      line-height: 1.6;
    }

    textarea:focus {
      outline: none;
      border-color: #8be9fd;
    }

    textarea::placeholder {
      color: #555;
    }

    .slider-row {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 20px;
    }

    .slider-row label {
      margin-bottom: 0;
      white-space: nowrap;
      min-width: 60px;
    }

    input[type="range"] {
      flex: 1;
      -webkit-appearance: none;
      appearance: none;
      height: 6px;
      background: #333;
      border-radius: 3px;
      outline: none;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      background: #8be9fd;
      border-radius: 50%;
      cursor: pointer;
    }

    .slider-value {
      min-width: 40px;
      text-align: right;
      font-variant-numeric: tabular-nums;
      color: #8be9fd;
      font-weight: bold;
    }

    .controls {
      text-align: center;
      margin-bottom: 20px;
    }

    #playBtn {
      background: #50fa7b;
      color: #1a1a2e;
      border: none;
      border-radius: 8px;
      padding: 12px 40px;
      font-size: 1.5rem;
      font-weight: bold;
      cursor: pointer;
      transition: background 0.2s;
      letter-spacing: 0.05em;
    }

    #playBtn:hover {
      background: #69ff94;
    }

    #playBtn.playing {
      background: #ff5555;
      color: #fff;
    }

    #playBtn.playing:hover {
      background: #ff6e6e;
    }

    #status {
      text-align: center;
      font-size: 1.2rem;
      color: #666;
      min-height: 1.2em;
    }

    #status.error {
      color: #ff5555;
    }

    .hint {
      font-size: 1.3rem;
      color: #aaa;
      margin-bottom: 8px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Polyrhythm Player</h1>

    <canvas id="visualizer"></canvas>

    <label for="score">Score (1 line = 1 voice, notes separated by commas)</label>
    <div class="hint">Drums: kick, snare, hihat, clap, tom</div>
    <textarea id="score" placeholder="C4,D4,C4&#10;F4,G4,F4,G4">C4,D4,C4
F4,G4,F4,G4</textarea>

    <div class="slider-row">
      <label for="bpm">BPM</label>
      <input type="range" id="bpm" min="15" max="300" step="1" value="120">
      <span class="slider-value" id="bpmValue">120</span>
    </div>

    <div class="controls">
      <button id="playBtn">Play</button>
    </div>
    <div id="status"></div>
  </div>

  <script>
    $(function () {
      // --- State ---
      let playing = false;
      let synths = [];
      let loops = [];
      let voiceShapes = [];
      let animFrameId = null;
      let lastTransportSeconds = 0;

      // --- Restore from localStorage ---
      var savedScore = localStorage.getItem('polyrhythm_score');
      var savedBpm = localStorage.getItem('polyrhythm_bpm');
      if (savedScore !== null) $('#score').val(savedScore);
      if (savedBpm !== null) {
        $('#bpm').val(savedBpm);
        $('#bpmValue').text(savedBpm);
      }

      // --- Canvas setup ---
      const canvas = document.getElementById('visualizer');
      const ctx = canvas.getContext('2d');

      function resizeCanvas() {
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }
      resizeCanvas();
      $(window).on('resize', resizeCanvas);

      // --- Slider ---
      const $bpm = $('#bpm');
      const $bpmValue = $('#bpmValue');

      function bpmToT(bpm) {
        return 240 / bpm;
      }

      $bpm.on('input', function () {
        const bpm = parseFloat(this.value);
        $bpmValue.text(bpm);
        if (playing) {
          updateLoopIntervals(bpmToT(bpm));
        }
      });

      function updateLoopIntervals(t) {
        loops.forEach(function (loop) {
          const p = loop._polyP;
          loop.interval = t / p;
        });
      }

      // --- Drum definitions ---
      const DRUMS = {
        kick: {
          create: function () {
            return new Tone.MembraneSynth({
              pitchDecay: 0.05, octaves: 10,
              envelope: { attack: 0.001, decay: 0.4, sustain: 0, release: 0.1 },
              volume: -4
            }).toDestination();
          },
          trigger: function (synth, time) { synth.triggerAttackRelease('C1', '8n', time); }
        },
        snare: {
          create: function () {
            return new Tone.NoiseSynth({
              noise: { type: 'white' },
              envelope: { attack: 0.001, decay: 0.15, sustain: 0, release: 0.05 },
              volume: -14
            }).toDestination();
          },
          trigger: function (synth, time) { synth.triggerAttackRelease('16n', time); }
        },
        hihat: {
          create: function () {
            return new Tone.MetalSynth({
              frequency: 400, envelope: { attack: 0.001, decay: 0.05, release: 0.01 },
              harmonicity: 5.1, modulationIndex: 32, resonance: 4000, octaves: 1.5,
              volume: -21
            }).toDestination();
          },
          trigger: function (synth, time) { synth.triggerAttackRelease('32n', time); }
        },
        clap: {
          create: function () {
            return new Tone.NoiseSynth({
              noise: { type: 'pink' },
              envelope: { attack: 0.01, decay: 0.1, sustain: 0, release: 0.05 },
              volume: -8
            }).toDestination();
          },
          trigger: function (synth, time) { synth.triggerAttackRelease('16n', time); }
        },
        tom: {
          create: function () {
            return new Tone.MembraneSynth({
              pitchDecay: 0.03, octaves: 4,
              envelope: { attack: 0.001, decay: 0.3, sustain: 0, release: 0.1 },
              volume: -6
            }).toDestination();
          },
          trigger: function (synth, time) { synth.triggerAttackRelease('E2', '8n', time); }
        }
      };

      // --- Parse score ---
      function parseScore(text) {
        const lines = text.split('\n').filter(function (line) {
          return line.trim() !== '';
        });

        return lines.map(function (line) {
          const notes = line.split(',').map(function (s) { return s.trim(); });
          return notes.map(function (noteStr) {
            if (!noteStr) return null;
            // Try tonal note first
            const parsed = Tonal.Note.get(noteStr);
            if (!parsed.empty) return parsed.name;
            // Try drum name
            var drumKey = noteStr.toLowerCase();
            if (DRUMS[drumKey]) return { drum: drumKey };
            // Unknown → silent
            return null;
          });
        });
      }

      // --- Visualizer: build shapes ---
      function buildShapes(voices) {
        const rect = canvas.getBoundingClientRect();
        const cx = rect.width / 2;
        const cy = rect.height / 2;
        const count = voices.length;
        const maxRadius = Math.min(cx, cy) * 0.75;
        const minRadius = 20;

        voiceShapes = voices.map(function (notes, i) {
          const p = notes.length;
          const hue = (i * 360 / count) % 360;
          const color = 'hsl(' + hue + ', 70%, 60%)';
          const colorBright = 'hsl(' + hue + ', 90%, 80%)';

          // Distribute radii: innermost = smallest, outermost = largest
          var radius;
          if (count === 1) {
            radius = maxRadius * 0.6;
          } else {
            radius = minRadius + (maxRadius - minRadius) * (i / (count - 1));
          }

          // Compute vertices
          var vertices = [];
          if (p === 1) {
            vertices = [{ x: cx, y: cy }];
          } else if (p === 2) {
            vertices = [
              { x: cx - radius, y: cy },
              { x: cx + radius, y: cy }
            ];
          } else {
            for (var j = 0; j < p; j++) {
              var angle = -Math.PI / 2 + (2 * Math.PI * j) / p;
              vertices.push({
                x: cx + radius * Math.cos(angle),
                y: cy + radius * Math.sin(angle)
              });
            }
          }

          return {
            p: p,
            notes: notes,
            vertices: vertices,
            color: color,
            colorBright: colorBright,
            radius: radius,
            highlightTime: 0
          };
        });
      }

      // --- Visualizer: draw frame ---
      function drawFrame() {
        const rect = canvas.getBoundingClientRect();
        const w = rect.width;
        const h = rect.height;
        ctx.clearRect(0, 0, w, h);

        if (voiceShapes.length === 0) return;

        const t = bpmToT(parseFloat($bpm.val()));
        const now = Date.now();

        if (playing) {
          lastTransportSeconds = Tone.getTransport().seconds;
        }
        const elapsed = lastTransportSeconds % t;
        const progress = elapsed / t;

        voiceShapes.forEach(function (shape) {
          const p = shape.p;
          const verts = shape.vertices;

          // Draw polygon edges
          ctx.strokeStyle = shape.color;
          ctx.globalAlpha = 0.3;
          ctx.lineWidth = 1.5;
          if (p === 1) {
            // Single point: draw a small circle marker
            ctx.beginPath();
            ctx.arc(verts[0].x, verts[0].y, 4, 0, Math.PI * 2);
            ctx.stroke();
          } else if (p === 2) {
            ctx.beginPath();
            ctx.moveTo(verts[0].x, verts[0].y);
            ctx.lineTo(verts[1].x, verts[1].y);
            ctx.stroke();
          } else {
            ctx.beginPath();
            ctx.moveTo(verts[0].x, verts[0].y);
            for (var j = 1; j < p; j++) {
              ctx.lineTo(verts[j].x, verts[j].y);
            }
            ctx.closePath();
            ctx.stroke();
          }

          // Draw vertices as small dots
          ctx.globalAlpha = 0.5;
          ctx.fillStyle = shape.color;
          verts.forEach(function (v) {
            ctx.beginPath();
            ctx.arc(v.x, v.y, 3, 0, Math.PI * 2);
            ctx.fill();
          });

          // Draw note labels near vertices
          ctx.globalAlpha = 0.7;
          ctx.fillStyle = shape.color;
          ctx.font = '16px "Segoe UI", Arial, sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          var cx = canvas.getBoundingClientRect().width / 2;
          var cy = canvas.getBoundingClientRect().height / 2;
          verts.forEach(function (v, j) {
            var n = shape.notes[j];
            var label = n === null ? '—' : (typeof n === 'string' ? n : n.drum);
            var offsetDist = 18;
            var dx = v.x - cx;
            var dy = v.y - cy;
            var dist = Math.sqrt(dx * dx + dy * dy);
            var lx, ly;
            if (dist < 1) {
              // p=1 center point: place label above
              lx = v.x;
              ly = v.y - offsetDist;
            } else {
              lx = v.x + (dx / dist) * offsetDist;
              ly = v.y + (dy / dist) * offsetDist;
            }
            ctx.fillText(label, lx, ly);
          });

          // Compute moving dot position
          var dotX, dotY;
          if (p === 1) {
            dotX = verts[0].x;
            dotY = verts[0].y;
          } else {
            var idx = Math.floor(progress * p) % p;
            var frac = (progress * p) - Math.floor(progress * p);
            var nextIdx = (idx + 1) % p;
            dotX = verts[idx].x + (verts[nextIdx].x - verts[idx].x) * frac;
            dotY = verts[idx].y + (verts[nextIdx].y - verts[idx].y) * frac;
          }

          // Highlight effect
          var timeSinceHighlight = now - shape.highlightTime;
          var isHighlighted = timeSinceHighlight < 150;

          ctx.globalAlpha = 1.0;
          if (isHighlighted) {
            // Glow effect
            var glowFade = 1 - (timeSinceHighlight / 150);
            var glowRadius = 6 + 12 * glowFade;
            ctx.fillStyle = shape.colorBright;
            ctx.shadowColor = shape.colorBright;
            ctx.shadowBlur = 20 * glowFade;
            ctx.beginPath();
            ctx.arc(dotX, dotY, glowRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
          } else {
            // Normal dot
            ctx.fillStyle = shape.color;
            ctx.beginPath();
            ctx.arc(dotX, dotY, 5, 0, Math.PI * 2);
            ctx.fill();
          }

          ctx.globalAlpha = 1.0;
        });

        animFrameId = requestAnimationFrame(drawFrame);
      }

      function startAnimation() {
        if (animFrameId) cancelAnimationFrame(animFrameId);
        animFrameId = requestAnimationFrame(drawFrame);
      }

      function stopAnimation() {
        // Draw one last frame in stopped state, then stop looping
        if (animFrameId) cancelAnimationFrame(animFrameId);
        drawFrame(); // render final state
        if (animFrameId) cancelAnimationFrame(animFrameId);
        animFrameId = null;
      }

      // --- Play / Stop ---
      $('#playBtn').on('click', async function () {
        if (playing) {
          stop();
        } else {
          await start();
        }
      });

      async function start() {
        await Tone.start();

        const text = $('#score').val();
        const voices = parseScore(text);

        if (voices.length === 0) {
          showStatus('No valid lines found.', true);
          return;
        }

        // Save to localStorage
        localStorage.setItem('polyrhythm_score', text);
        localStorage.setItem('polyrhythm_bpm', $bpm.val());

        const t = bpmToT(parseFloat($bpm.val()));

        // Build visualizer shapes
        buildShapes(voices);
        lastTransportSeconds = 0;

        voices.forEach(function (notes, voiceIndex) {
          const p = notes.length;
          if (p === 0) return;

          // Determine which synths this voice needs
          var hasMelody = notes.some(function (n) { return typeof n === 'string'; });
          var drumTypes = {};
          notes.forEach(function (n) {
            if (n !== null && typeof n === 'object' && n.drum) {
              drumTypes[n.drum] = true;
            }
          });

          // Create melody synth if needed
          var melodySynth = null;
          if (hasMelody) {
            melodySynth = new Tone.PolySynth(Tone.Synth, {
              oscillator: { type: 'triangle' },
              envelope: { attack: 0.005, decay: 0.3, sustain: 0.05, release: 0.4 },
              volume: -8
            }).toDestination();
            synths.push(melodySynth);
          }

          // Create drum synths for each type used in this voice
          var drumSynths = {};
          Object.keys(drumTypes).forEach(function (key) {
            var ds = DRUMS[key].create();
            drumSynths[key] = ds;
            synths.push(ds);
          });

          let noteIndex = 0;
          const interval = t / p;

          const loop = new Tone.Loop(function (time) {
            const note = notes[noteIndex % p];
            if (note !== null) {
              if (typeof note === 'string') {
                melodySynth.triggerAttackRelease(note, '16n', time);
              } else if (note.drum && drumSynths[note.drum]) {
                DRUMS[note.drum].trigger(drumSynths[note.drum], time);
              }
            }
            // Trigger highlight for this voice
            if (voiceShapes[voiceIndex]) {
              voiceShapes[voiceIndex].highlightTime = Date.now();
            }
            noteIndex++;
            if (noteIndex >= p) noteIndex = 0;
          }, interval);

          loop._polyP = p;
          loops.push(loop);
          loop.start(0);
        });

        Tone.getTransport().start();
        playing = true;
        $('#playBtn').addClass('playing').text('Stop');
        showStatus('');
        startAnimation();
      }

      function stop() {
        Tone.getTransport().stop();
        Tone.getTransport().cancel();

        loops.forEach(function (loop) { loop.dispose(); });
        loops = [];

        synths.forEach(function (synth) { synth.dispose(); });
        synths = [];

        playing = false;
        $('#playBtn').removeClass('playing').text('Play');
        showStatus('');
        stopAnimation();
      }

      function showStatus(msg, isError) {
        const $s = $('#status');
        $s.text(msg);
        if (isError) {
          $s.addClass('error');
        } else {
          $s.removeClass('error');
        }
      }
    });
  </script>
</body>
</html>
